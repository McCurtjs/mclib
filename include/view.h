/*******************************************************************************
* MIT License
*
* Copyright (c) 2025 Curtis McCoy
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/

#ifndef MCLIB_VIEW_H_
#define MCLIB_VIEW_H_

//
// Container View
//
// A view represent a read-only window into a non-owning contiguous segment of
// memory. It can be used to access values in arrays and run various operations
// that don't modify the underlying data, such as searching or partitioning.
//
// Type specialization:
// A type-specific view can be generated by defining the following:
//
//  - con_type:   the type the view contains.
//  - con_prefix: [optional] overrides the default name of the container.
//  - con_cmp:    [optional] a `compare_nosize_fn` that can be used for
//                operations like searching or partitioning. If not included, a
//                default comparison function will be generated using memcmp.
//
// When defined, the following will be created:
//
// #define con_type A
// #define con_prefix a
// #define con_cmp compare_fn
// #include "view.h"
// #undef con_type
// #undef con_prefix
// #undef con_cmp
//
// // Create
// view_a_t view_a_build(const A* begin, const A* end);
// view_a_t view_a_range(const A* begin, index_t size);
// view_a_t view_a(const A* begin, index_t size);
// view_a_t view_a_cast(view_t);
//
// // Utility
// index_t  view_a_size(view_a_t);
// index_t  view_a_size_bytes(view_a_t);
// bool     view_a_is_empty(view_a_t);
// bool     view_a_eq(view_a_t lhs, view_a_t rhs);
// bool     view_a_eq_deep(view_a_t lhs, view_a_t rhs);
// bool     view_a_is_ordered(view_a_t);
//
// // Accessors
// const A* view_a_ref(view_a_t, index_t);
// const A* view_a_ref_front(view_a_t);
// const A* view_a_ref_back(view_a_t);
//
// bool     view_a_read(view_a_t, index_t, A* out);
// bool     view_a_read_front(view_a_t,  A* out);
// bool     view_a_read_back(view_a_t, A* out);
//
// A        view_a_get(view_a_t, index_t);
// A        view_a_get_front(view_a_t);
// A        view_a_get_back(view_a_t);
//
// // Subsets
// view_a_t view_a_subview(view_a_t, index_t start, index_t end);
// view_a_t view_a_drop(view_a_t, index_t count);
// view_a_t view_a_take(view_a_t, index_t count);
// view_a_t view_a_split(view_a_t, index_t pivot);
// view_a_t view_a_partition(view_a_t, const A* del);
//
// // Algorithm
// index_t  view_a_match_index(view_a_t, predicate_fn);
// const A* view_a_match_ref(vuew_a_t, predicate_fn);
// bool     view_a_match(view_a_t, predicate_fn, A* out);
// bool     view_a_match_contains(view_a_t, predicate_fn);
//
// index_t  view_a_find_index(view_a_t, const A* item);
// const A* view_a_find_ref(view_a_t, const A* item);
// bool     view_a_find(view_a_t, const A* item, A* out);
// bool     view_a_contains(view_a_t, const A* item);
//
// index_t  view_a_search_index(view_a_t, const A* item);
// const A* view_a_search_ref(view_a_t, const A* item);
// bool     view_a_search(view_a_t, const A* item, A* out);
// bool     view_a_search_contains(view_a_t, const A* item);
//

#include "types.h"
#include "span_base.h"

// Create pair_view_t and partition_view_t
#define tuple_type view_t
#include "pair.h"
#define delim_type const void*
#define tuple_pair_type pair_view_t
#include "partition.h"
#undef tuple_pair_type
#undef delim_type
#undef tuple_type

////////////////////////////////////////////////////////////////////////////////
// Accessors
////////////////////////////////////////////////////////////////////////////////

index_t view_size_bytes(view_t view);
index_t view_size(view_t view, index_t element_size);
bool    view_is_empty(view_t view);

const void* view_ref(view_t view, index_t index, index_t element_size);
const void* view_ref_front(view_t view);
const void* view_ref_back(view_t view, index_t element_size);

bool view_read(view_t view, index_t index, void* out, index_t element_size);
bool view_read_front(view_t view, void* out, index_t element_size);
bool view_read_back(view_t view, void* out, index_t element_size);

bool view_eq(view_t lhs, view_t rhs);
bool view_eq_deep(view_t lhs, view_t rhs, compare_nosize_fn cmp, index_t elsz);
bool view_is_ordered(view_t view, compare_nosize_fn cmp, index_t element_size);

////////////////////////////////////////////////////////////////////////////////
// Sub-ranges
////////////////////////////////////////////////////////////////////////////////

view_t view_subview(view_t view, index_t start, index_t end, index_t el_size);
view_t view_drop(view_t view, index_t count, index_t element_size);
view_t view_take(view_t view, index_t count, index_t element_size);
pair_view_t view_split(view_t view, index_t element_size);
pair_view_t view_split_at(view_t view, index_t pivot, index_t element_size);
partition_view_t view_partition(
  view_t view, const void* del, compare_nosize_fn compare, index_t element_size
);
partition_view_t view_partition_at(view_t view, index_t index, index_t el_size);
partition_view_t view_partition_match(
  view_t view, predicate_fn matcher, index_t element_size
);

////////////////////////////////////////////////////////////////////////////////
// Algorithm-searching
////////////////////////////////////////////////////////////////////////////////

// linear predicate seek
index_t view_match_index(
  view_t view, predicate_fn matcher, index_t element_size
);
const void* view_match_ref(
  view_t view, predicate_fn matcher, index_t element_size
);
bool view_match(
  view_t view, predicate_fn matcher, void* out_value, index_t element_size
);
bool view_match_contains(
  view_t view, predicate_fn matcher, index_t element_size
);

// linear search
index_t view_find_index(
  view_t view, const void* item, compare_nosize_fn cmp, index_t element_size
);
const void* view_find_ref(
  view_t view, const void* item, compare_nosize_fn cmp, index_t element_size
);
bool view_find(
  view_t view, const void* item, void* out_value,
  compare_nosize_fn cmp, index_t element_size
);
bool view_contains(
  view_t view, const void* item, compare_nosize_fn cmp, index_t element_size
);

// binary search
index_t view_search_index(
  view_t view, const void* item, compare_nosize_fn cmp, index_t element_size
);
const void* view_search_ref(
  view_t view, const void* item, compare_nosize_fn cmp, index_t element_size
);
bool view_search(
  view_t view, const void* item, void* out_value,
  compare_nosize_fn cmp, index_t element_size
);
bool view_search_contains(
  view_t view, const void* item, compare_nosize_fn cmp, index_t element_size
);

#endif

////////////////////////////////////////////////////////////////////////////////
// Templatized type specialization
////////////////////////////////////////////////////////////////////////////////

#ifdef con_type

#ifdef con_prefix
# define _con_name con_prefix
#else
# define _con_name con_type
#endif

#define _view_type MACRO_CONCAT3(view_, _con_name, _t)
#define _pair_type MACRO_CONCAT(pair_, _view_type)
#define _partition_type MACRO_CONCAT(partition_, _view_type)
#define _prefix(_fn) MACRO_CONCAT3(view_, _con_name, _fn)

typedef struct _view_type {
  union {
    view_t base;
    struct {
      const con_type* begin;
      const con_type* end;
    };
  };
} _view_type;

#define tuple_type _view_type
#define tuple_pair_type _pair_type
#define tuple_partition_type _partition_type
#define delim_type const con_type*
#include "pair.h"
#include "partition.h"
#undef tuple_type
#undef tuple_pair_type
#undef tuple_partition_type
#undef delim_type

#ifdef con_cmp
# define _con_cmp con_cmp
#elif !defined(con_no_cmp)
# define _con_cmp MACRO_CONCAT3(_view_, _con_name, _cmp)
extern int memcmp(const void* lhs, const void* rhs, size_t size);
static int _con_cmp(const void* lhs, const void* rhs) {
  if (lhs == rhs) return 0;
  if (!lhs || !rhs) return lhs ? 1 : -1;
  return memcmp(lhs, rhs, sizeof(con_type));
}
#endif

////////////////////////////////////////////////////////////////////////////////

static inline _view_type _prefix(_build)
(const con_type* begin, const con_type* end) {
  assert(begin <= end);
  return (_view_type) { .begin = begin, .end = end };
}

static inline _view_type _prefix(_range)
(const con_type* begin, index_t size) {
  assert(size >= 0);
  assert(begin || !size);
  return (_view_type) { .begin = begin, .end = begin + size };
}

static inline _view_type MACRO_CONCAT(view_, _con_name)
(const con_type* begin, index_t size) {
  return _prefix(_range)(begin, size);
}

static inline _view_type _prefix(_cast)
(view_t view) {
  return *(_view_type*)&view;
}

static inline index_t _prefix(_size)
(_view_type view) {
  return view_size(view.base, sizeof(con_type));
}

static inline index_t _prefix(_size_bytes)
(_view_type view) {
  return view_size_bytes(view.base);
}

static inline bool _prefix(_is_empty)
(_view_type view) {
  return view_is_empty(view.base);
}

static inline bool _prefix(_eq)
(_view_type lhs, _view_type rhs) {
  return view_eq(lhs.base, rhs.base);
}

static inline const con_type* _prefix(_ref)
(_view_type view, index_t index) {
  return view_ref(view.base, index, sizeof(con_type));
}

static inline const con_type* _prefix(_ref_front)
(_view_type view) {
  return view_ref_front(view.base);
}

static inline const con_type* _prefix(_ref_back)
(_view_type view) {
  if (view_is_empty(view.base)) return NULL;
  return view.end - 1;
}

static inline bool _prefix(_read)
(_view_type view, index_t index, con_type* out) {
  return view_read(view.base, index, out, sizeof(con_type));
}

static inline bool _prefix(_read_front)
(_view_type view, con_type* out) {
  return view_read_front(view.base, out, sizeof(con_type));
}

static inline bool _prefix(_read_back)
(_view_type view, con_type* out) {
  return view_read_back(view.base, out, sizeof(con_type));
}

static inline con_type _prefix(_get)
(_view_type view, index_t index) {
  const con_type* ret = view_ref(view.base, index, sizeof(con_type));
  assert(ret);
  return *ret;
}

static inline con_type _prefix(_get_front)
(_view_type view) {
  const con_type* ret = view_ref_front(view.base);
  assert(ret);
  return *ret;
}

static inline con_type _prefix(_get_back)
(_view_type view) {
  const con_type* ret = view_ref_back(view.base, sizeof(con_type));
  assert(ret);
  return *ret;
}

static inline _view_type _prefix(_subview)
(_view_type view, index_t start, index_t end) {
  view.base = view_subview(view.base, start, end, sizeof(con_type));
  return view;
}

static inline _view_type _prefix(_drop)
(_view_type view, index_t count) {
  view.base = view_drop(view.base, count, sizeof(con_type));
  return view;
}

static inline _view_type _prefix(_take)
(_view_type view, index_t count) {
  view.base = view_take(view.base, count, sizeof(con_type));
  return view;
}

static inline _pair_type _prefix(_split)
(_view_type view) {
  pair_view_t pair = view_split(view.base, sizeof(con_type));
  return *(_pair_type*)&pair;
}

static inline _pair_type _prefix(_split_at)
(_view_type view, index_t pivot) {
  pair_view_t pair = view_split_at(view.base, pivot, sizeof(con_type));
  return *(_pair_type*)&pair;
}

static inline _partition_type _prefix(_partition_at)
(_view_type view, index_t index) {
  partition_view_t ret = view_partition_at(view.base, index, sizeof(con_type));
  return *(_partition_type*)&ret;
}

static inline _partition_type _prefix(_partition_match)
(_view_type view, predicate_fn matcher) {
  partition_view_t partition = view_partition_match(
    view.base, matcher, sizeof(con_type)
  );
  return *(_partition_type*)&partition;
}

static inline index_t _prefix(_match_index)
(_view_type view, predicate_fn matcher) {
  return view_match_index(view.base, matcher, sizeof(con_type));
}

static inline const con_type* _prefix(_match_ref)
(_view_type view, predicate_fn matcher) {
  return view_match_ref(view.base, matcher, sizeof(con_type));
}

static inline bool _prefix(_match)
(_view_type view, predicate_fn matcher, con_type* out_found) {
  return view_match(view.base, matcher, out_found, sizeof(con_type));
}

static inline bool _prefix(_match_contains)
(_view_type view, predicate_fn matcher) {
  return view_match_contains(view.base, matcher, sizeof(con_type));
}

#ifdef _con_cmp

static inline bool _prefix(_eq_deep)
(_view_type lhs, _view_type rhs) {
  return view_eq_deep(lhs.base, rhs.base, _con_cmp, sizeof(con_type));
}

static inline bool _prefix(_is_ordered)
(_view_type view) {
  return view_is_ordered(view.base, _con_cmp, sizeof(con_type));
}

static inline _partition_type _prefix(_partition)
(_view_type view, const con_type* del) {
  partition_view_t part = view_partition(
    view.base, del, _con_cmp, sizeof(con_type)
  );
  return *(_partition_type*)&part;
}

static inline index_t _prefix(_find_index)
(_view_type view, const con_type* item) {
  return view_find_index(view.base, item, _con_cmp, sizeof(con_type));
}

static inline const con_type* _prefix(_find_ref)
(_view_type view, const con_type* item) {
  return view_find_ref(view.base, item, _con_cmp, sizeof(con_type));
}

static inline bool _prefix(_find)
(_view_type view, const con_type* item, con_type* out_found) {
  return view_find(view.base, item, out_found, _con_cmp, sizeof(con_type));
}

static inline bool _prefix(_contains)
(_view_type view, const con_type* item) {
  return view_contains(view.base, item, _con_cmp, sizeof(con_type));
}

static inline index_t _prefix(_search_index)
(_view_type view, const con_type* item) {
  return view_search_index(view.base, item, _con_cmp, sizeof(con_type));
}

static inline const con_type* _prefix(_search_ref)
(_view_type view, const con_type* item) {
  return view_search_ref(view.base, item, _con_cmp, sizeof(con_type));
}

static inline bool _prefix(_search)
(_view_type view, const con_type* item, con_type* out_found) {
  return view_search(view.base, item, out_found, _con_cmp, sizeof(con_type));
}

static inline bool _prefix(_search_contains)
(_view_type view, const con_type* item) {
  return view_search_contains(view.base, item, _con_cmp, sizeof(con_type));
}

#endif

#undef _con_name
#undef _con_cmp
#undef _view_type
#undef _pair_type
#undef _partition_type
#undef _prefix

#endif

